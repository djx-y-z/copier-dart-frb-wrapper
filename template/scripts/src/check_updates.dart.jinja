/// Update checking utilities for {{ native_library_name }}.
///
/// Provides functions to check for upstream updates, compare versions,
/// and update rust/Cargo.toml.
library;

import 'dart:convert';
import 'dart:io';

import 'common.dart';

/// GitHub repository for upstream {{ native_library_name }} releases.
const _upstreamRepo = '{{ native_repo }}';

/// Result of checking for updates.
class UpdateCheckResult {
  /// Current version from rust/Cargo.toml (upstream tag).
  final String currentVersion;

  /// Latest version from upstream GitHub releases.
  final String latestVersion;

  /// Whether an update is needed.
  final bool needsUpdate;

  /// Whether the latest release is a prerelease.
  final bool isPrerelease;

  /// URL to the release page on GitHub.
  final String releaseUrl;

  const UpdateCheckResult({
    required this.currentVersion,
    required this.latestVersion,
    required this.needsUpdate,
    required this.isPrerelease,
    required this.releaseUrl,
  });

  Map<String, dynamic> toJson() => {
        'current_version': currentVersion,
        'latest_version': latestVersion,
        'needs_update': needsUpdate,
        'is_prerelease': isPrerelease,
        'release_url': releaseUrl,
      };
}

/// Result of performing an update check with optional update.
class PerformUpdateResult {
  /// The update check result.
  final UpdateCheckResult checkResult;

  /// Whether files were updated.
  final bool updated;

  /// List of files that were updated.
  final List<String> updatedFiles;

  const PerformUpdateResult({
    required this.checkResult,
    required this.updated,
    this.updatedFiles = const [],
  });
}

/// Checks for updates from upstream GitHub releases.
///
/// If [targetVersion] is provided, checks against that specific version.
/// Otherwise, fetches the latest release from GitHub.
///
/// Returns [UpdateCheckResult] with comparison information.
Future<UpdateCheckResult> checkForUpdates({
  String? targetVersion,
  bool silent = false,
}) async {
  // Read current version from rust/Cargo.toml
{% if upstream_crate or upstream_crates %}
  final currentVersion = getUpstreamVersion();
{% else %}
  final currentVersion = getCrateVersion();
{% endif %}

  if (!silent) {
    logInfo('Current {{ native_library_name }} version: $currentVersion');
  }

  // Get target version (either specified or fetch latest)
  String latestVersion;
  bool isPrerelease;
  String releaseUrl;

  if (targetVersion != null) {
    latestVersion = targetVersion;
    isPrerelease = _isPrerelease(latestVersion);
    releaseUrl = 'https://github.com/$_upstreamRepo/releases/tag/$targetVersion';
    if (!silent) {
      logInfo('Checking against specified version: $latestVersion');
    }
  } else {
    if (!silent) {
      logStep('Fetching latest release from GitHub...');
    }
    final release = await _fetchLatestRelease();
    latestVersion = release['tag_name'] as String;
    isPrerelease = release['prerelease'] as bool? ?? false;
    releaseUrl = release['html_url'] as String? ??
        'https://github.com/$_upstreamRepo/releases';
    if (!silent) {
      logInfo('Latest upstream version: $latestVersion');
    }
  }

  // Compare versions (normalize for comparison)
  final currentNorm = _normalizeVersion(currentVersion);
  final latestNorm = _normalizeVersion(latestVersion);
  final comparison = compareVersions(currentNorm, latestNorm);
  final needsUpdate = comparison < 0;

  return UpdateCheckResult(
    currentVersion: currentVersion,
    latestVersion: latestVersion,
    needsUpdate: needsUpdate,
    isPrerelease: isPrerelease,
    releaseUrl: releaseUrl,
  );
}

/// Normalize version by removing 'v' prefix for comparison.
String _normalizeVersion(String version) {
{% if strip_version_prefix %}
  if (version.startsWith('v')) {
    return version.substring(1);
  }
{% endif %}
  return version;
}

/// Check if a version is a prerelease.
bool _isPrerelease(String version) {
  return version.contains('-') ||
      version.contains('alpha') ||
      version.contains('beta') ||
      version.contains('rc');
}

/// Fetch the latest release from GitHub API.
Future<Map<String, dynamic>> _fetchLatestRelease() async {
  final token = Platform.environment['GITHUB_TOKEN'] ??
      Platform.environment['GH_TOKEN'];

  final client = HttpClient();
  try {
    final url = Uri.parse(
      'https://api.github.com/repos/$_upstreamRepo/releases/latest',
    );
    final request = await client.getUrl(url);
    if (token != null && token.isNotEmpty) {
      request.headers.set('Authorization', 'token $token');
    }
    request.headers.set('Accept', 'application/vnd.github.v3+json');
    request.headers.set('User-Agent', '{{ package_name }}-update-checker');

    final response = await request.close();
    final body = await response.transform(utf8.decoder).join();

    if (response.statusCode == 200) {
      return jsonDecode(body) as Map<String, dynamic>;
    } else {
      throw Exception(
        'Failed to fetch latest release: ${response.statusCode}',
      );
    }
  } finally {
    client.close();
  }
}

/// Update upstream version in all relevant files.
///
/// Updates:
{% if upstream_crate or upstream_crates %}
/// - rust/Cargo.toml (upstream dependency tag)
{% endif %}
/// - README.md (badge) - if exists
/// - CLAUDE.md (example) - if exists (enable_claude=true)
/// - SKILL.md (example) - if exists (enable_claude=true)
///
/// Returns list of updated file names.
Future<List<String>> updateVersionFiles({
  required String newVersion,
  required String oldVersion,
  bool silent = false,
}) async {
  final packageDir = getPackageDir();
  final updatedFiles = <String>[];

{% if upstream_crate %}
  // 1. Update rust/Cargo.toml (upstream dependency tag)
  if (!silent) logStep('Updating rust/Cargo.toml...');
  final cargoFile = File('${packageDir.path}/rust/Cargo.toml');
  if (!cargoFile.existsSync()) {
    throw Exception('rust/Cargo.toml not found');
  }
  var cargoContent = cargoFile.readAsStringSync();

  // Update upstream dependency tag
  // Matches: {{ upstream_crate }} = { git = "...", tag = "vX.Y.Z" }
  final tagPattern = RegExp(
    r'({{ upstream_crate }}\s*=\s*\{[^}]*tag\s*=\s*")[^"]+(")',
  );

  cargoContent = cargoContent.replaceAllMapped(
    tagPattern,
    (match) => '${match.group(1)}$newVersion${match.group(2)}',
  );

  await cargoFile.writeAsString(cargoContent);
  updatedFiles.add('rust/Cargo.toml');
  if (!silent) logInfo('Updated rust/Cargo.toml: tag = "$newVersion"');
{% elif upstream_crates %}
  // 1. Update rust/Cargo.toml (all upstream dependency tags)
  if (!silent) logStep('Updating rust/Cargo.toml...');
  final cargoFile = File('${packageDir.path}/rust/Cargo.toml');
  if (!cargoFile.existsSync()) {
    throw Exception('rust/Cargo.toml not found');
  }
  var cargoContent = cargoFile.readAsStringSync();

  // Update all upstream dependency tags
{% for crate in upstream_crates.split(',') | map('trim') | select %}
  final tagPattern{{ loop.index }} = RegExp(
    r'({{ crate }}\s*=\s*\{[^}]*tag\s*=\s*")[^"]+(")',
  );
  cargoContent = cargoContent.replaceAllMapped(
    tagPattern{{ loop.index }},
    (match) => '${match.group(1)}$newVersion${match.group(2)}',
  );
{% endfor %}

  await cargoFile.writeAsString(cargoContent);
  updatedFiles.add('rust/Cargo.toml');
  if (!silent) logInfo('Updated rust/Cargo.toml: tag = "$newVersion"');
{% endif %}

  // 2. Update README.md badge (if exists)
  final readmeFile = File('${packageDir.path}/README.md');
  if (readmeFile.existsSync()) {
    if (!silent) logStep('Updating README.md badge...');
    var content = readmeFile.readAsStringSync();
    // Match badge pattern: [![name](https://img.shields.io/badge/name-vX.Y.Z-orange.svg)]
    final badgePattern = RegExp(
      r'(\[!\[{{ native_library_name }}\]\(https://img\.shields\.io/badge/{{ native_library_name }}-)v?[0-9]+\.[0-9]+\.[0-9]+[^)]*(-orange\.svg\)\])',
    );
    if (badgePattern.hasMatch(content)) {
      content = content.replaceAllMapped(
        badgePattern,
        (match) => '${match.group(1)}$newVersion${match.group(2)}',
      );
      await readmeFile.writeAsString(content);
      updatedFiles.add('README.md');
      if (!silent) logInfo('Updated README.md badge');
    }
  }

  // 3. Update CLAUDE.md example (if exists - enable_claude=true)
  final claudeFile = File('${packageDir.path}/CLAUDE.md');
  if (claudeFile.existsSync()) {
    if (!silent) logStep('Updating CLAUDE.md...');
    var content = claudeFile.readAsStringSync();
    // Replace version in example: tag = "vX.Y.Z"
    content = content.replaceAll(
      'tag = "$oldVersion"',
      'tag = "$newVersion"',
    );
    await claudeFile.writeAsString(content);
    updatedFiles.add('CLAUDE.md');
    if (!silent) logInfo('Updated CLAUDE.md example');
  }

  // 4. Update SKILL.md example (if exists - enable_claude=true)
  final skillFile = File(
    '${packageDir.path}/.claude/skills/update-{{ package_name }}/SKILL.md',
  );
  if (skillFile.existsSync()) {
    if (!silent) logStep('Updating SKILL.md...');
    var content = skillFile.readAsStringSync();
    // Replace version in example: tag = "vX.Y.Z"
    content = content.replaceAll(
      'tag = "$oldVersion"',
      'tag = "$newVersion"',
    );
    await skillFile.writeAsString(content);
    updatedFiles.add('.claude/skills/update-{{ package_name }}/SKILL.md');
    if (!silent) logInfo('Updated SKILL.md example');
  }

  return updatedFiles;
}

/// Perform full update check with optional update.
Future<PerformUpdateResult> performUpdateCheck({
  String? targetVersion,
  bool doUpdate = false,
  bool force = false,
  bool silent = false,
}) async {
  final checkResult = await checkForUpdates(
    targetVersion: targetVersion,
    silent: silent,
  );

  var updated = false;
  List<String> updatedFiles = [];
  if (doUpdate && (checkResult.needsUpdate || force)) {
    updatedFiles = await updateVersionFiles(
      newVersion: checkResult.latestVersion,
      oldVersion: checkResult.currentVersion,
      silent: silent,
    );
    updated = true;
  }

  return PerformUpdateResult(
    checkResult: checkResult,
    updated: updated,
    updatedFiles: updatedFiles,
  );
}

/// Write outputs to GitHub Actions output file.
Future<void> writeGitHubOutputs({
  required UpdateCheckResult checkResult,
  required bool updated,
}) async {
  final githubOutput = Platform.environment['GITHUB_OUTPUT'];
  if (githubOutput == null) return;

  final file = File(githubOutput);
  final buffer = StringBuffer();

  buffer.writeln('current_version=${checkResult.currentVersion}');
  buffer.writeln('latest_version=${checkResult.latestVersion}');
  buffer.writeln('needs_update=${checkResult.needsUpdate}');
  buffer.writeln('is_prerelease=${checkResult.isPrerelease}');
  buffer.writeln('release_url=${checkResult.releaseUrl}');
  buffer.writeln('updated=$updated');

  await file.writeAsString(buffer.toString(), mode: FileMode.append);
}

/// Print results as JSON.
void printJsonOutput({
  required UpdateCheckResult checkResult,
  required bool updated,
}) {
  final output = <String, dynamic>{
    ...checkResult.toJson(),
    'updated': updated,
  };

  const encoder = JsonEncoder.withIndent('  ');
  print(encoder.convert(output));
}

/// Print update summary in human-readable format.
void printUpdateSummary({
  required UpdateCheckResult checkResult,
  required bool updated,
  List<String> updatedFiles = const [],
}) {
  print('');
  print('========================================');
  print('  {{ native_library_name | to_camel }} Update Check');
  print('========================================');
  print('');
  print('  Current version: ${checkResult.currentVersion}');
  print('  Latest version:  ${checkResult.latestVersion}');
  print('');

  if (checkResult.needsUpdate) {
    print('  ${Colors.colorize('Update available!', Colors.green)}');
  } else {
    print('  ${Colors.colorize('Already up to date', Colors.green)}');
  }

  if (checkResult.isPrerelease) {
    print('  ${Colors.colorize('(pre-release)', Colors.yellow)}');
  }

  if (updated && updatedFiles.isNotEmpty) {
    print('');
    print('  ${Colors.colorize('Files updated:', Colors.green)}');
    for (final file in updatedFiles) {
      print('    ${Colors.colorize('âœ“', Colors.green)} $file');
    }
    print('');
    print('  ${Colors.colorize('Next steps:', Colors.cyan)}');
    print('    1. Run: make update (to update Cargo.lock)');
    print('    2. Run: make codegen (if API changed)');
    print('    3. Update CHANGELOG.md');
    print('    4. Run: make test');
    print('    5. Commit and push changes');
  }
  print('');
}
