/// Main entry point for the {{ package_name }} library.
///
/// Provides initialization, version information, and high-level API access.
library;

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'platform/platform.dart' as platform;
import 'rust/frb_generated.dart';

/// Native asset ID for the {{ package_name }} library.
/// Format: package:{{ package_name }}/{{ package_name }}
///
/// When the build hook registers a CodeAsset with this ID,
/// Dart allows loading it via DynamicLibrary.open() with this ID.
const _nativeAssetId = 'package:{{ package_name }}/{{ package_name }}';

/// Main API class for {{ package_name }}.
///
/// Use [{{ package_name | to_camel }}.init] to initialize the library before using any
/// operations.
///
/// ```dart
/// void main() async {
///   await {{ package_name | to_camel }}.init();
///   // ... use {{ package_name }} APIs
/// }
/// ```
///
/// ## Library Loading
///
/// The native library is loaded automatically based on the platform:
///
/// ### For Native Platforms (iOS, Android, macOS, Linux, Windows)
///
/// 1. **Native Assets** (Dart 3.10+): If the build hook registered the library
/// 2. **Custom path**: If provided via [libraryPath] parameter
/// 3. **Package directory**: Found via `package_config.json`
/// 4. **CWD**: `rust/target/release/` relative to current directory
/// 5. **FRB default**: For Flutter apps with Cargokit
///
{% if enable_web %}
/// ### For Web
///
/// The WASM module is loaded from the `pkg/` directory automatically.
/// Custom library paths are not supported on web.
///
{% endif %}
/// ### For Flutter apps
///
/// Cargokit automatically builds the native library{% if enable_web %} or WASM module{% endif %}.
/// No manual setup required.
///
/// ### For pure Dart CLI apps
///
/// Option 1: Build locally
/// ```bash
/// cargo build --release --manifest-path rust/Cargo.toml
/// ```
///
/// Option 2: Run `dart pub get` to trigger the build hook (requires Dart 3.10+)
class {{ package_name | to_camel }} {
  // coverage:ignore-start
  {{ package_name | to_camel }}._();
  // coverage:ignore-end

  /// Track initialization per isolate (or single instance on web).
  static final Set<int> _initializedIsolates = {};

  /// Track if FRB has been initialized (global, not per-isolate).
  static bool _frbInitialized = false;

  /// Initialize the {{ package_name }} library.
  ///
  /// This should be called once before using any {{ package_name }} operations.
  /// It's safe to call multiple times - subsequent calls are no-ops.
  ///
  /// The [libraryPath] parameter allows specifying a custom absolute path
  /// to the native library. If not provided, the library will be searched
  /// automatically. **Note:** This parameter is ignored on web.
  ///
  /// For multi-isolate applications, call this in each isolate that
  /// uses {{ package_name }}.
  static Future<void> init({String? libraryPath}) async {
    final isolateId = platform.getIsolateId();

    if (_initializedIsolates.contains(isolateId)) {
      return;
    }

    // Initialize FRB (Flutter Rust Bridge) only once
    if (!_frbInitialized) {
      final library = await _loadLibrary(libraryPath);
      await RustLib.init(externalLibrary: library);
      _frbInitialized = true;
    }

    _initializedIsolates.add(isolateId);
  }

  /// Load the native library from the best available location.
  static Future<ExternalLibrary> _loadLibrary(String? customPath) async {
    // coverage:ignore-start
{% if enable_web %}
    // On web, always use the default WASM loading
    if (platform.kIsWeb) {
      return await loadExternalLibrary(
        RustLib.kDefaultExternalLibraryLoaderConfig,
      );
    }
{% endif %}
    // coverage:ignore-end

    // 1. Try custom path first (native only)
    if (customPath != null) {
      return platform.openLibraryFromPath(customPath); // coverage:ignore-line
    }

    // 2. Try native assets (Dart 3.10+ with build hook)
    final nativeAssetLib = platform.tryLoadNativeAsset(_nativeAssetId);
    if (nativeAssetLib != null) {
      return nativeAssetLib;
    }

    // 3. Try to find the library in known locations
    final libraryName = platform.getLibraryName();
    final packageRoot = platform.findPackageRoot();
    final filePath = platform.findLibraryPath(libraryName, packageRoot);
    if (filePath != null) {
      return platform.openLibraryFromPath(filePath);
    }

    // coverage:ignore-start
    // 4. Fall back to FRB's default loading (Flutter with Cargokit)
    return await loadExternalLibrary(
      RustLib.kDefaultExternalLibraryLoaderConfig,
    );
    // coverage:ignore-end
  }

  /// Whether the library has been initialized in the current isolate.
  static bool get isInitialized {
    final isolateId = platform.getIsolateId();
    return _initializedIsolates.contains(isolateId);
  }

  /// Ensures the library is initialized.
  ///
  /// Throws [StateError] if not initialized.
  static void ensureInitialized() {
    if (!isInitialized) {
      throw StateError(
        '{{ package_name | to_camel }} not initialized. Call await {{ package_name | to_camel }}.init() first.',
      );
    }
  }

  /// Clean up resources for the current isolate.
  ///
  /// By default, this only resets the isolate's initialization state.
  ///
  /// For CLI applications that are exiting, set [dispose] to `true` to
  /// also dispose the Flutter Rust Bridge runtime.
  ///
  /// **Note:** After `cleanup(dispose: true)`, you cannot reinitialize
  /// in the same process (FRB limitation).
  static void cleanup({bool dispose = false}) {
    final isolateId = platform.getIsolateId();
    _initializedIsolates.remove(isolateId);

    // coverage:ignore-start
    if (dispose && _initializedIsolates.isEmpty) {
      RustLib.dispose();
    }
    // coverage:ignore-end
  }
}

/// Base mixin for {{ package_name }} operations.
mixin {{ package_name | to_camel }}Base {
  /// Ensures the library is initialized.
  static void ensureInit() {
    {{ package_name | to_camel }}.ensureInitialized();
  }
}
